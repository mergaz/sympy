#!/opt/local/bin/python
# coding=utf-8

from __future__ import print_function
import sys
import os
if len(sys.path[0]) > 0:
    sys.path.append(sys.path[0])
    sys.path.append(os.path.join(sys.path[0], '../'))
    os.chdir(sys.path[0])
else:
    sys.path.append('./')
    sys.path.append('../')

import sympy
from sympy.core.basic import Basic
from sympy.core.relational import StrictGreaterThan, StrictLessThan, GreaterThan, LessThan
from sympy.core.cache import *
import csv
import cProfile
try:
    from sympy.utilities.solution import last_solution, reset_solution, setStrOutput
    SOLUTIONS=True
except:
    SOLUTIONS=False

from datetime import datetime
from time import *
import threading
try:
    import thread
except ImportError:
    import _thread as thread

from functools import wraps
import errno
import glob
import signal
from copy import copy
from traceback import print_exc, format_exception, print_tb, print_stack
import subprocess

try:
    from colorama import init, Fore, Back, Style
    init()
    COLORS=True
except:
    COLORS=False

TIMEOUT=8

def default_state():
    return {'Passed': 0, 'Missed': 0, 'Answer': 0, 'Timeout': 0, 'Exception': 0}

class Colored:
    def __init__(self, style):
        self.style = style
    def __enter__(self):
        if COLORS:
            print (self.style, end='')
        return self
    def __exit__(self, exc_type, exc_value, traceback):
        if COLORS:
            print (Fore.RESET+Back.RESET+Style.RESET_ALL, end='')

DEBUG=False

def debug(*args, **kwargs):
    if DEBUG:
        style = Style.DIM if COLORS else 0
        with Colored(style):
            for arg in args:
                print (arg, end=' ')
            for key, value in kwargs.items():
                print (key, value, end=' ')
            print()

def error(*args, **kwargs):
    style = Style.BRIGHT+Fore.RED if COLORS else 0
    with Colored(style):
        for arg in args:
            print (arg, end=' ')
        for key, value in kwargs.items():
            print (key, value, end=' ')
        print()

def message(*args, **kwargs):
    style = Style.BRIGHT if COLORS else 0
    with Colored(style):
        for arg in args:
            print (arg, end=' ')
        for key, value in kwargs.items():
            print (key, value, end=' ')
        #print()

def separator(*args, **kwargs):
    try:
        # Unix/MacOS
        rows, columns = subprocess.check_output(['stty', 'size']).split()
        rows = int(rows)
        columns = int(columns)
    except:
        # Windows
        rows, columns = (
            int(os.environ.get('LINES', 25)),
            int(os.environ.get('COLUMNS', 80)))
    style = Style.BRIGHT+Fore.GREEN if COLORS else 0
    with Colored(style):
        if len(args) > 1:
            str = ' '.join(*args)
        elif len(args) == 1:
            str = args[0]
        else:
            str = ''
        for key, value in kwargs.items():
            str += key + ' ' + value + ' '
        l = len(str)
        sl = (columns-l-2)/2
        print('='*sl, end=' ')
        print(str, end=' ')
        print('='*(columns-sl-l-2))

class Tristate(object):
    def __init__(self, val=None):
        if val is None or val == True or val == False:
            self.value = val
        else:
            raise ValueError("Tristate value must be True, False, or None. Got %s" % type(value))
    def __eq__(self, other):
        return self.value == other
    def __ne__(self, other):
        return self.value != other
    def __nonzero__(self):   # Python 3: __bool__()
        return self.value == True
    def __str__(self):
        return str(self.value)
    def __repr__(self):
        return "Tristate(%s)" % self.value

class TimeoutError(Exception):
    pass

class timeout:
    def __init__(self, seconds=1, error_message='Timeout'):
        self.seconds = seconds
        self.error_message = error_message
    def handle_timeout(self, signum, frame):
        raise TimeoutError(self.error_message)
    def __enter__(self):
        if hasattr(signal, "SIGALRM"):
            signal.signal(signal.SIGALRM, self.handle_timeout)
        if hasattr(signal, "alarm"):
            signal.alarm(self.seconds)
    def __exit__(self, type, value, traceback):
        if hasattr(signal, "alarm"):
            signal.alarm(0)

def tostring(A):
    if isinstance(A, list):
        s = '['
        for index, it in enumerate(A):
            if index > 0:
                s += ', '
            s += tostring(it)
        s += ']'
        return s
    else:
        return A.__str__()

def unlist(A):
    if isinstance(A, list):
        result = []
        for it in A:
            result.extend(unlist(it))
        return result
    else:
        return (A,)

def equal(A, B, **kwargs):
    try:
        A = sympy.simplify(A)
    except :
        debug('An exception while simplify', A)
        pass
    try:
        B = sympy.simplify(B)
    except:
        debug('An exception while simplify', B)
        pass
    debug( A, B )
    debug( type(A), type(B))
    if 'precision' in kwargs:
        precision = kwargs['precision']
        debug('Precision', precision)
    else:
        precision = 0.001
    #if DEBUG:
    #    print_stack()
    if A == B:
        debug( 'Ok')
        return Tristate(True)
    if type(A) is type(B):
        if isinstance(A, Basic):
            if A.is_Boolean:
                # And, Or, Not
                if len(A.args) == len(B.args):
                    counter = 0
                    args2 = list(B.args)
                    for arg in A.args:
                        for arg2 in args2:
                            if equal(arg, arg2, **kwargs) == True:
                                args2.remove(arg2)
                                debug( 'Remove equal pair', arg, arg2)
                                counter += 1
                                break
                    if counter == len(A.args):
                        return Tristate(True)
                    else:
                        debug( '===] ', A.args, args2)
                        return Tristate(False)
            elif A.is_Relational:
                # Gt, Lt...
                if len(A.args) == len(B.args):
                    for ind in range(len(A.args)):
                        arg1 = A.args[ind]
                        arg2 = B.args[ind]
                        res = equal(arg1, arg2, **kwargs)
                        if res is not True:
                            debug( 'Pair not equal', arg1, arg2)
                            return res
                    return Tristate(True)
            elif A.is_Float:
                res = sympy.Abs(A - B) < precision
                debug( 'Float:', A, B, A - B, res)
                return Tristate(res)
            elif A.is_Number:
                debug('Numbers:', A, B)
                return Tristate(A == B)
            elif isinstance(A, sympy.Expr):
                # expressions
                if A.is_commutative:
                    # Add or Mul
                    debug('Test expressions:', A, B)
                    res = equal(list(A.args), list(B.args), **kwargs)
                    if res != True:
                        res = Tristate(False)
                    return res
        elif isinstance(A, list):
            #if len(A) == 1 and isinstance(A[0], list):
            #    A = A[0]
            #if len(B) == 1 and isinstance(B[0], list):
            #    B = B[0]
            A = unlist(A)
            B = unlist(B)
            counter = 0
            args2 = list(B)
            for arg1 in A:
                for arg2 in args2:
                    debug('Test equality for:', arg1, arg2)
                    if equal(arg1, arg2, **kwargs):
                        args2.remove(arg2)
                        counter += 1
                        break
            # test for exact equality
            if len(A) == len(B) == counter:
                return Tristate(True)
            # test for partial equality
            elif counter > 0:
                return Tristate(None)
            else:
                return Tristate(False)
    else:
        if isinstance(A, Basic) and isinstance(B, Basic):
            if A.is_Relational and B.is_Relational and len(A.args)==2 and len(B.args)==2:
                if isinstance(A, StrictLessThan) and isinstance(B, StrictGreaterThan):
                    return equal(A.args[0], B.args[1], **kwargs) and equal(A.args[1], B.args[0], **kwargs)
                elif isinstance(A, StrictGreaterThan) and isinstance(B, StrictLessThan):
                    return equal(A.args[0], B.args[1], **kwargs) and equal(A.args[1], B.args[0], **kwargs)
                elif isinstance(A, LessThan) and isinstance(B, GreaterThan):
                    return equal(A.args[0], B.args[1], **kwargs) and equal(A.args[1], B.args[0], **kwargs)
                elif isinstance(A, GreaterThan) and isinstance(B, LessThan):
                    return equal(A.args[0], B.args[1], **kwargs) and equal(A.args[1], B.args[0], **kwargs)
            elif A.is_Number and B.is_Number:
                return Tristate(A == B)
            elif isinstance(A, sympy.And) and B.is_Relational:
                # compare the pair of bounds with one bound
                # And(-oo < x, x < 0) with x < 0
                #
                second = None
                if isinstance(B, GreaterThan) or isinstance(B, StrictGreaterThan):
                    if B.args[0].is_Symbol:
                        second = StrictLessThan(B.args[0], sympy.oo)
                    elif B.args[1].is_Symbol:
                        second = StrictGreaterThan(B.args[1], -sympy.oo)
                if isinstance(B, LessThan) or isinstance(B, StrictLessThan):
                    if B.args[0].is_Symbol:
                        second = StrictGreaterThan(B.args[0], -sympy.oo)
                    elif B.args[1].is_Symbol:
                        second = StrictLessThan(B.args[1], sympy.oo)
                if second is not None:
                    return equal(A, sympy.And(B, second), **kwargs)
                else:
                    result = equal(list(A.args), B, **kwargs)
                    if result == True:
                        result = Tristate(None)
            elif A.is_Relational and isinstance(B, sympy.And):
                # compare the pair of bounds with one bound
                # x < 0 with And(-oo < x, x < 0)
                #
                return equal(B, A, **kwargs)
            elif A.is_Boolean:
                # And, Or, Not
                result = equal(list(A.args), B, **kwargs)
                if result == True:
                    result = Tristate(None)
                return result
            elif B.is_Boolean:
                # And, Or, Not
                result = equal(A, list(B.args), **kwargs)
                if result == True:
                    result = Tristate(None)
                return result
            elif A.is_Symbol and B.is_Symbol:
                n1 = A.name.replace('_', '')
                n2 = B.name.replace('_', '')
                debug(n1, n2)
                return Tristate(n1 == n2)
            elif A.is_Number and isinstance(B, sympy.Expr):
                B = sympy.N(B)
                debug('Test number and function', A, B)
                return Tristate(A == B)
            elif isinstance(A, sympy.Expr) and B.is_Number:
                A = sympy.N(A)
                debug('Test number and function', A, B)
                return Tristate(A == B)
            elif A.is_Equality:
                nonsymbol = None
                for s in A.args:
                    if not s.is_Symbol:
                        if nonsymbol is not None:
                            debug('Warning, two non symbols in Eq', A.args)
                        nonsymbol = s
                if nonsymbol is not None:
                    return equal(nonsymbol, B)
            elif B.is_Equality:
                nonsymbol = None
                for s in B.args:
                    if not s.is_Symbol:
                        if nonsymbol is not None:
                            debug('Warning, two non symbols in Eq', B.args)
                        nonsymbol = s
                if nonsymbol is not None:
                    return equal(A, nonsymbol)
            elif isinstance(A, sympy.Expr) and isinstance(B, sympy.Expr):
                debug('Test two expressions', A, B)
                A1 = sympy.N(A)
                B1 = sympy.N(B)
                if A1 != A or B1 != B:
                    return equal(A1, B1, **kwargs)
                else:
                    # the numerical result not differ
                    debug('Can\'t compare expressions')
            elif isinstance(A, sympy.FiniteSet):
                return equal(list(A), B, **kwargs)
            elif isinstance(B, sympy.FiniteSet):
                return equal(A, list(B), **kwargs)
            else:
                debug('Unknown pair')
        elif isinstance(A, list):
            counter = 0
            for arg in A:
                if equal(arg, B, **kwargs) == True:
                    counter += 1
            debug('List A', len(A), counter)
            if counter == 0:
                return Tristate(False)
            elif counter < len(A):
                return Tristate(None)
            else:
                return Tristate(True)
        elif isinstance(B, list):
            counter = 0
            for arg in B:
                if equal(A, arg, **kwargs) == True:
                    counter += 1
            debug('List B', len(B), counter)
            if counter == 0:
                return Tristate(False)
            elif counter < len(B):
                return Tristate(None)
            else:
                return Tristate(True)
    return Tristate(False)

class Test:
    def __init__(self, files):
        now = datetime.today()
        fname = ""
        filenames = ''
        for f in files:
            if len(filenames) > 0:
                filenames = filenames + ','
            filenames = filenames + f[:-4]
        self.filename = 'result_{1},{0:%Y.%m.%d}_{0:%S}.csv'.format(now, filenames)
        self.file = open(self.filename, 'wb')
        self.writer = csv.writer(self.file, delimiter=",")
        self.writer.writerows([['Function', 'Input', 'Expected', 'Result', 'Solution steps', 'Status']])
        self.file_solutions = open(self.filename[:-4]+'_solutions.txt', 'wb')
        self.tests_total = 0
        self.tests_count = 0
        self.min_time = -1
        self.max_time = -1
        self.all_time = 0

    def __enter__(self):
        if DEBUG:
            self.profile_filename = self.filename[:-3] + 'prof'
            self.profiler = cProfile.Profile()
        else:
            self.profiler = None
        return self

    def __exit__(self, type, value, traceback):
        self.finish()

    def finish(self):
        if self.file is not None:
            self.file.close()
            self.file = None
        self.writer = None
        if self.file_solutions is not None:
            self.file_solutions.close()
            self.file_solutions = None
        if self.profiler is not None:
            self.profiler.dump_stats(self.profile_filename)

    def process(self, *arg):
        if len(arg) < 2: return None
        if arg[0].startswith('#'): return None
        comments = [a.strip()[1:] for a in arg if a.strip().startswith('#')]
        params = [a.strip() for a in arg if not a.strip().startswith('#')]

        func = params[0] if len(params) > 0 else None
        args = params[1:-1] if len(params) > 1 else None
        answer = params[-1] if len(params) > 2 else None
        arguments = []
        sol = []
        status = 'Unknown'
        result = None
        eq = False
        approximate = False
        try:
            message('Process('
                + str(self.tests_count) + '/'
                + str(self.tests_total) + '):',
                *args)
            if isinstance(func, basestring):
                func = getattr(sympy, func)
                if func is None:
                    return False
            for a in args:
                if isinstance(a, basestring):
                    # HACK
                    a = a.replace('abs', 'Abs')
                    arguments.append(sympy.sympify(a, evaluate=True)) # evaluate=False
                else:
                    arguments.append(a)
            if answer == '???':
                answer = None
            if isinstance(answer, basestring):
                ind = answer.find('≈')
                if ind >= 0:
                    approximate = True
                    if ind == 0:
                        answer = answer.replace('≈', '')
                    else:
                        answer = answer.replace('≈', '=')
                answer = sympy.sympify(answer, evaluate=True) # evaluate=False
            if SOLUTIONS:
                reset_solution()
                setStrOutput()
            with timeout(seconds=TIMEOUT):
                if self.profiler is not None:
                    result = self.profiler.runcall(func, *arguments)
                else:
                    result = func(*arguments)
            if SOLUTIONS:
                sol = last_solution()
            if result is None:
                eq = False
                status = 'Answer'
            elif (isinstance(result, list) and len(result) == 0) or (result == False and not result.is_number):
                if (isinstance(answer, list) and len(answer) == 0) or (answer == False and not answer.is_number):
                    debug ('No solutions (Passed):', answer, result)
                    eq = True
                    status = 'Passed'
                else:
                    debug ('No solutions (Answer):', answer, result)
                    eq = False
                    status = 'Answer'
            elif answer is None:
                debug ('Expected no solutions: Passed')
                eq = True
                status = 'Passed'
            else:
                with timeout(seconds=15):
                    debug ('Result', result)
                    debug ('Answer', answer)
                    debug ('Solution', sol)
                    if approximate:
                        if isinstance(result, list):
                            result = [sympy.N(x) for x in result]
                        else:
                            result = sympy.N(result)
                        eq = equal(result, answer, precision=0.01)
                    else:
                        eq = equal(result, answer)
                if eq == True:
                    status = 'Passed'
                elif eq == False:
                    status = 'Answer'
                else:
                    status = 'Missed'
        except KeyboardInterrupt:
            status = 'Timeout'
        except TimeoutError:
            style = Fore.BLUE if COLORS else 0
            with Colored(style):
                print()
                res = format_exception(sys.exc_type, sys.exc_value, sys.exc_traceback)
                for line in res:
                    print(line)
            status = 'Timeout'
        except Exception as e:
            style = Fore.RED if COLORS else 0
            with Colored(style):
                print()
                res = format_exception(sys.exc_type, sys.exc_value, sys.exc_traceback)
                for line in res:
                    print(line)
            status = 'Exception'
        except RuntimeError as e:
            style = Fore.RED if COLORS else 0
            with Colored(style):
                print()
                res = format_exception(sys.exc_type, sys.exc_value, sys.exc_traceback, limit, file)
                for line in res:
                    print(line)
            status = 'Exception'
        finally:
            funcname = func
            if not isinstance(funcname, basestring):
                funcname = func.__name__
            self.writer.writerows([[funcname, args, tostring(answer), tostring(result), len(sol), status] + comments])
            #self.file.flush()
            message('\t\t', status)
            print()
            
            # write solutions
            self.file_solutions.write('[========================================]\n')
            self.file_solutions.write('Process({0}/{1}): {2}\t{3}\n'.format(self.tests_count, self.tests_total, args, status))
            self.file_solutions.write('\n')
            for line in sol:
                self.file_solutions.write(line+'\n')
            self.file_solutions.write('\n')
        return status

    def load_file(self, filename):
        stats = default_state()
        with open(filename, 'rb') as csvfile:
            # Count number of lines first - memory-friendly way
            self.tests_total = sum(1 for line in csvfile)
            self.tests_count = 1
            csvfile.seek(0)
            separator(filename)
            reader = csv.reader(csvfile, delimiter=';', quotechar='"')
            skip = False
            for row in reader:
                if len(row):
                    if row[0].startswith('###'):
                        skip = not skip
                    elif not skip:
                        t1 = time()
                        res = self.process(*row)
                        if res is not None:
                            t2 = time()
                            t = t2 - t1
                            if self.min_time < 0 or self.min_time > t:
                                self.min_time = t
                            if self.max_time < t:
                                self.max_time = t
                            self.all_time += t
                            stats[res] = stats[res] + 1
                        self.tests_count += 1
            message('Result:', filename)
            print()
            message(**stats)
            print()
        return stats

if __name__ == '__main__':
    stats = default_state()
    files = {}
    testfiles = []
    resfilename = ''
    if len(sys.argv) > 1:
        for f in sys.argv[1:]:
            if f == '-d':
                DEBUG = True
                continue
            elif f.startswith('-t'):
                newtimeout = int(f[3:])
                if newtimeout > 0:
                    TIMEOUT = newtimeout
                continue
            else:
                testfiles.append(f)
    else:
        for f in glob.glob('*.csv'):
            if f.startswith('test_'):
                print ('Skip', f)
            elif f.startswith('result_'):
                print ('Skip', f)
            elif f.startswith('compare_'):
                print ('Skip', f)
            else:
                testfiles.append(f)
    mint = 0
    maxt = 0
    allt = 0
    medt = 0
    with Test(testfiles) as test:
        rescount = 0
        for f in testfiles:
            res = test.load_file(f)
            files[f] = res
            for key, value in res.items():
                stats[key] += value
                rescount += value
        resfilename = test.filename
        mint = test.min_time
        maxt = test.max_time
        allt = test.all_time
        medt = test.all_time / rescount
    separator('Statistics')
    totaltests = 0
    totalcorrect = 0
    for key, value in files.items():
        message(key, ':', **value)
        print()
        for v in value:
            totaltests += value[v]
        totalcorrect += value['Passed']
    message('Total:', **stats)
    print()
    message('Min time: {0:.2f} Max time: {1:.2f} Median time: {2:.2f} Total time: {3:.2f}\nCorrect: {4}%'.format(mint, maxt, medt, allt, totalcorrect*100/totaltests))
    print()
    message('Log file:', resfilename)
    print()
    #if DEBUG:
    #    print_cache()

