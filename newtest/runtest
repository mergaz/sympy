#!/opt/local/bin/python
# coding=utf-8

from __future__ import print_function
import sys
import os
if len(sys.path[0]) > 0:
    sys.path.append(sys.path[0])
    sys.path.append(os.path.join(sys.path[0], '../'))
    os.chdir(sys.path[0])
else:
    sys.path.append('./')
    sys.path.append('../')

import sympy
from sympy.core.basic import Basic
from sympy.core.relational import StrictGreaterThan, StrictLessThan, GreaterThan, LessThan
import csv
try:
    from sympy.utilities.solution import last_solution, reset_solution
    SOLUTIONS=True
except:
    SOLUTIONS=False

from datetime import datetime
import threading
try:
    import thread
except ImportError:
    import _thread as thread

from functools import wraps
import errno
import glob
import signal
from copy import copy
from traceback import print_exc, format_exception, print_tb, print_stack
import subprocess

try:
    from colorama import init, Fore, Back, Style
    init()
    COLORS=True
except:
    COLORS=False

TIMEOUT=15

def default_state():
    return {'Passed': 0, 'Missed': 0, 'Answer': 0, 'Timeout': 0, 'Exception': 0}

class Colored:
    def __init__(self, style):
        self.style = style
    def __enter__(self):
        if COLORS:
            print (self.style, end='')
        return self
    def __exit__(self, exc_type, exc_value, traceback):
        if COLORS:
            print (Fore.RESET+Back.RESET+Style.RESET_ALL, end='')

DEBUG=False

def debug(*args, **kwargs):
    if DEBUG:
        style = Style.DIM if COLORS else 0
        with Colored(style):
            for arg in args:
                print (arg, end=' ')
            for key, value in kwargs.items():
                print (key, value, end=' ')
            print()

def error(*args, **kwargs):
    style = Style.BRIGHT+Fore.RED if COLORS else 0
    with Colored(style):
        for arg in args:
            print (arg, end=' ')
        for key, value in kwargs.items():
            print (key, value, end=' ')
        print()

def message(*args, **kwargs):
    style = Style.BRIGHT if COLORS else 0
    with Colored(style):
        for arg in args:
            print (arg, end=' ')
        for key, value in kwargs.items():
            print (key, value, end=' ')
        #print()

def separator(*args, **kwargs):
    try:
        # Unix/MacOS
        rows, columns = subprocess.check_output(['stty', 'size']).split()
        rows = int(rows)
        columns = int(columns)
    except:
        # Windows
        rows, columns = (
            int(os.environ.get('LINES', 25)),
            int(os.environ.get('COLUMNS', 80)))
    style = Style.BRIGHT+Fore.GREEN if COLORS else 0
    with Colored(style):
        if len(args) > 1:
            str = ' '.join(*args)
        elif len(args) == 1:
            str = args[0]
        else:
            str = ''
        for key, value in kwargs.items():
            str += key + ' ' + value + ' '
        l = len(str)
        sl = (columns-l-2)/2
        print('='*sl, end=' ')
        print(str, end=' ')
        print('='*(columns-sl-l-2))

class Tristate(object):
    def __init__(self, val=None):
        if val is None or val == True or val == False:
            self.value = val
        else:
            raise ValueError("Tristate value must be True, False, or None. Got %s" % type(value))
    def __eq__(self, other):
        return self.value == other
    def __ne__(self, other):
        return self.value != other
    def __nonzero__(self):   # Python 3: __bool__()
        return self.value == True
    def __str__(self):
        return str(self.value)
    def __repr__(self):
        return "Tristate(%s)" % self.value

class TimeoutError(Exception):
    pass

class timeout:
    def __init__(self, seconds=1, error_message='Timeout'):
        self.seconds = seconds
        self.error_message = error_message
    def handle_timeout(self, signum, frame):
        raise TimeoutError(self.error_message)
    def __enter__(self):
        if hasattr(signal, "SIGALRM"):
            signal.signal(signal.SIGALRM, self.handle_timeout)
        if hasattr(signal, "alarm"):
            signal.alarm(self.seconds)
    def __exit__(self, type, value, traceback):
        if hasattr(signal, "alarm"):
            signal.alarm(0)

def tostring(A):
    if isinstance(A, list):
        s = '['
        for index, it in enumerate(A):
            if index > 0:
                s += ', '
            s += tostring(it)
        s += ']'
        return s
    else:
        return A.__str__()

def equal(A, B, **kwargs):
    A = sympy.simplify(A)
    B = sympy.simplify(B)
    debug( A, B )
    debug( type(A), type(B))
    if 'precision' in kwargs:
        precision = kwargs['precision']
        debug('Precision', precision)
    else:
        precision = 0.001
    #if DEBUG:
    #    print_stack()
    if A == B:
        debug( 'Ok')
        return Tristate(True)
    if type(A) is type(B):
        if isinstance(A, Basic):
            if A.is_Boolean:
                # And, Or, Not
                if len(A.args) == len(B.args):
                    counter = 0
                    args2 = list(B.args)
                    for arg in A.args:
                        for arg2 in args2:
                            if equal(arg, arg2, **kwargs) == True:
                                args2.remove(arg2)
                                debug( 'Remove equal pair', arg, arg2)
                                counter += 1
                                break
                    if counter == len(A.args):
                        return Tristate(True)
                    else:
                        debug( '===] ', A.args, args2)
                        return Tristate(False)
            elif A.is_Relational:
                # Gt, Lt...
                if len(A.args) == len(B.args):
                    for ind in range(len(A.args)):
                        arg1 = A.args[ind]
                        arg2 = B.args[ind]
                        res = equal(arg1, arg2, **kwargs)
                        if res is not True:
                            debug( 'Pair not equal', arg1, arg2)
                            return res
                    return Tristate(True)
            elif A.is_Float:
                res = sympy.Abs(A - B) < precision
                debug( 'Float:', A, B, A - B, res)
                return Tristate(res)
            elif A.is_Number:
                debug('Numbers:', A, B)
                return Tristate(A == B)
            elif isinstance(A, sympy.Expr):
                # expressions
                if A.is_commutative:
                    # Add or Mul
                    debug('Test expressions:', A, B)
                    res = equal(list(A.args), list(B.args), **kwargs)
                    if res != True:
                        res = Tristate(False)
                    return res
        elif isinstance(A, list):
            counter = 0
            args2 = list(B)
            for arg1 in A:
                for arg2 in args2:
                    debug('Test equality for:', arg1, arg2)
                    if equal(arg1, arg2, **kwargs):
                        args2.remove(arg2)
                        counter += 1
                        break
            # test for exact equality
            if len(A) == len(B) == counter:
                return Tristate(True)
            # test for partial equality
            elif counter > 0:
                return Tristate(None)
            else:
                return Tristate(False)
    else:
        if isinstance(A, Basic) and isinstance(B, Basic):
            if A.is_Relational and B.is_Relational and len(A.args)==2 and len(B.args)==2:
                if isinstance(A, StrictLessThan) and isinstance(B, StrictGreaterThan):
                    return equal(A.args[0], B.args[1], **kwargs) and equal(A.args[1], B.args[0], **kwargs)
                elif isinstance(A, StrictGreaterThan) and isinstance(B, StrictLessThan):
                    return equal(A.args[0], B.args[1], **kwargs) and equal(A.args[1], B.args[0], **kwargs)
                elif isinstance(A, LessThan) and isinstance(B, GreaterThan):
                    return equal(A.args[0], B.args[1], **kwargs) and equal(A.args[1], B.args[0], **kwargs)
                elif isinstance(A, GreaterThan) and isinstance(B, LessThan):
                    return equal(A.args[0], B.args[1], **kwargs) and equal(A.args[1], B.args[0], **kwargs)
            elif A.is_Number and B.is_Number:
                return Tristate(A == B)
            elif A.is_Boolean:
                # And, Or, Not
                result = equal(list(A.args), B, **kwargs)
                if result == True:
                    result = Tristate(None)
                return result
            elif B.is_Boolean:
                # And, Or, Not
                result = equal(A, list(B.args), **kwargs)
                if result == True:
                    result = Tristate(None)
                return result
            elif A.is_Symbol and B.is_Symbol:
                n1 = A.name.replace('_', '')
                n2 = B.name.replace('_', '')
                debug(n1, n2)
                return Tristate(n1 == n2)
            elif A.is_Number and isinstance(B, sympy.Expr):
                B = sympy.N(B)
                debug('Test number and function', A, B)
                return Tristate(A == B)
            elif isinstance(A, sympy.Expr) and B.is_Number:
                A = sympy.N(A)
                debug('Test number and function', A, B)
                return Tristate(A == B)
            elif isinstance(A, sympy.Expr) and isinstance(B, sympy.Expr):
                debug('Test two expressions', A, B)
                A1 = sympy.N(A)
                B1 = sympy.N(B)
                if A1 != A or B1 != B:
                    return equal(A1, B1, **kwargs)
                else:
                    # the numerical result not differ
                    debug('Can\'t compare expressions')
            elif isinstance(A, sympy.FiniteSet):
                return equal(list(A), B, **kwargs)
            elif isinstance(B, sympy.FiniteSet):
                return equal(A, list(B), **kwargs)
            else:
                debug('Unknown pair')
        elif isinstance(A, list):
            counter = 0
            for arg in A:
                if equal(arg, B, **kwargs) == True:
                    counter += 1
            debug('List A', len(A), counter)
            if counter == 0:
                return Tristate(False)
            elif counter < len(A):
                return Tristate(None)
            else:
                return Tristate(True)
        elif isinstance(B, list):
            counter = 0
            for arg in B:
                if equal(A, arg, **kwargs) == True:
                    counter += 1
            debug('List B', len(B), counter)
            if counter == 0:
                return Tristate(False)
            elif counter < len(B):
                return Tristate(None)
            else:
                return Tristate(True)
    return Tristate(False)

class Test:
    def __init__(self, files):
        now = datetime.today()
        fname = ""
        filenames = ''
        for f in files:
            if len(filenames) > 0:
                filenames = filenames + ','
            filenames = filenames + f[:-4]
        self.filename = 'result_{1},{0:%Y.%m.%d}_{0:%S}.csv'.format(now, filenames)
        self.file = open(self.filename, 'wb')
        self.writer = csv.writer(self.file, delimiter=",")
        self.writer.writerows([['Function', 'Input', 'Expected', 'Result', 'Solution steps', 'Status']])
        self.tests_total = 0
        self.tests_count = 0

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if self.file is not None:
            self.finish()

    def finish(self):
        self.file.close()
        self.file = None
        self.writer = None

    def process(self, *arg):
        if len(arg) < 2: return None
        if arg[0].startswith('#'): return None
        comments = [a.strip()[1:] for a in arg if a.strip().startswith('#')]
        params = [a.strip() for a in arg if not a.strip().startswith('#')]

        func = params[0] if len(params) > 0 else None
        args = params[1:-1] if len(params) > 1 else None
        answer = params[-1] if len(params) > 2 else None
        arguments = []
        sol = []
        status = 'Unknown'
        result = None
        eq = False
        approximate = False
        try:
            message('Process('
                + str(self.tests_count) + '/'
                + str(self.tests_total) + '):',
                *args)
            if isinstance(func, basestring):
                func = getattr(sympy, func)
                if func is None:
                    return False
            for a in args:
                if isinstance(a, basestring):
                    # HACK
                    a = a.replace('abs', 'Abs')
                    arguments.append(sympy.sympify(a))
                else:
                    arguments.append(a)
            if answer == '???':
                answer = None
            if isinstance(answer, basestring):
                ind = answer.find('≈')
                if ind >= 0:
                    approximate = True
                    if ind == 0:
                        answer = answer.replace('≈', '')
                    else:
                        answer = answer.replace('≈', '=')
                    answer = sympy.sympify(answer)
            if SOLUTIONS:
                reset_solution()
            with timeout(seconds=TIMEOUT):
                result = func(*arguments)
            if SOLUTIONS:
                sol = last_solution()
            if result is None or result == False:
                eq = False
                status = 'Answer'
            if (isinstance(result, list) and len(result) == 0):
                if isinstance(answer, list) and len(answer) == 0:
                    eq = True
                    status = 'Passed'
                else:
                    eq = False
                    status = 'Answer'
            elif answer is None:
                eq = True
                status = 'Passed'
            else:
                with timeout(seconds=15):
                    debug ('Result', result)
                    debug ('Answer', answer)
                    debug ('Solution', sol)
                    if approximate:
                        if isinstance(result, list):
                            result = [sympy.N(x) for x in result]
                        else:
                            result = sympy.N(result)
                        eq = equal(result, answer, precision=0.01)
                    else:
                        eq = equal(result, answer)
                if eq == True:
                    status = 'Passed'
                elif eq == False:
                    status = 'Answer'
                else:
                    status = 'Missed'
        except KeyboardInterrupt:
            status = 'Timeout'
        except TimeoutError:
            style = Fore.BLUE if COLORS else 0
            with Colored(style):
                print()
                res = format_exception(sys.exc_type, sys.exc_value, sys.exc_traceback)
                for line in res:
                    print(line)
            status = 'Timeout'
        except Exception as e:
            style = Fore.RED if COLORS else 0
            with Colored(style):
                print()
                res = format_exception(sys.exc_type, sys.exc_value, sys.exc_traceback)
                for line in res:
                    print(line)
            status = 'Exception'
        except RuntimeError as e:
            style = Fore.RED if COLORS else 0
            with Colored(style):
                print()
                res = format_exception(sys.exc_type, sys.exc_value, sys.exc_traceback, limit, file)
                for line in res:
                    print(line)
            status = 'Exception'
        finally:
            funcname = func
            if not isinstance(funcname, basestring):
                funcname = func.__name__
            self.writer.writerows([[funcname, args, tostring(answer), tostring(result), len(sol), status] + comments])
            #self.file.flush()
            message('\t\t', status)
            print()
        return status

    def load_file(self, filename):
        stats = default_state()
        with open(filename, 'rb') as csvfile:
            # Count number of lines first - memory-friendly way
            self.tests_total = sum(1 for line in csvfile)
            self.tests_count = 0
            csvfile.seek(0)
            separator(filename)
            reader = csv.reader(csvfile, delimiter=';', quotechar='"')
            skip = False
            for row in reader:
                if len(row):
                    if row[0].startswith('###'):
                        skip = not skip
                    elif not skip:
                        res = self.process(*row)
                        self.tests_count += 1
                        if res is not None:
                            stats[res] = stats[res] + 1
            message('Result:', filename)
            print()
            message(**stats)
            print()
        return stats

if __name__ == '__main__':
    stats = default_state()
    files = {}
    testfiles = []
    resfilename = ''
    if len(sys.argv) > 1:
        for f in sys.argv[1:]:
            if f == '-d':
                DEBUG = True
                continue
            elif f.startswith('-t'):
                time = int(f[3:])
                if time > 0:
                    TIMEOUT = time
                continue
            else:
                testfiles.append(f)
    else:
        for f in glob.glob('*.csv'):
            if f.startswith('test_'):
                print ('Skip', f)
            elif f.startswith('result_'):
                print ('Skip', f)
            elif f.startswith('compare_'):
                print ('Skip', f)
            else:
                testfiles.append(f)
    with Test(testfiles) as test:
        for f in testfiles:
            res = test.load_file(f)
            files[f] = res
            for key, value in res.items():
                stats[key] += value
        resfilename = test.filename
    separator('Statistics')
    for key, value in files.items():
        message(key, ':', **value)
        print()
    message('Total:', **stats)
    print()
    message('Log file:', resfilename)
    print()
